#+TITLE: Felhantering i C#

Detta är underlag till en presentaion kring felhantering i C#.

Presentationen går igenom olika verktyg för att hantera fel. Från
enklare null returns till Result<TSuccess,TError> och hur dessa kan
slås ihop med Bind och användas med LINQ.

* Förslag på prompt starters

Nedan är några frågor du kan använda för att börja prompta

- Can du förklara för mig hur Bind funkar i CSharpFunctionalExtensions med Result<T,E>?
- Hur kan jag i CSharpFunctionalExtensions retunera en Result<T,E> discriminating union Error record
- Vad är fördelarna med CSharpFunctionalExtensions retunera en Result<T,E> discriminating union Error record

* [[./IfElseWithNull.cs][IfElseWithNull.cs]]

Koden hanterar fel genom enkla null-kontroller men detta är varken
robust eller tydligt. Det saknas riktig felhantering som exempelvis
try/catch, eller specifika feltyper. Att använda null som signal för
fel gör felsökning svårt, och returvärden används inte
konsekvent. Koden fungerar i enkel form, men bör förbättras för att
vara mer tydlig, tillförlitlig och underhållbar.

Metodsignaturen visar tydligt att den retunerar User eller null. Men
vi är begränsade i den information som null kan leverera.

#+BEGIN_SRC csharp
User? ValidateUser(string username)
#+END_SRC

* [[./TryCatch.cs][TryCatch.cs]]

I denna koden så kastar metoderna exceptions. Genom att kolla på
metodsignaturen så kan man inte se vilka Exceptions som retuneras och
utvecklaren måste gå in i metoden för att undersöka. Detta försvagar
möjlighten till att skapa abstraktioner och således ökar den kognitiva
lasten.

I Run så vet man inte vilken metod det var som gick gel.

#+BEGIN_SRC csharp
User ValidateUser(string username)
#+END_SRC

*  [[./TryCatchExceptionHierarchy.cs][TryCatchExceptionHierarchy.cs]]

I denna koden så har vi samma problem som i exemplet ovan, man kan
utifrån metodsignaturen inte avgöra vad som kan gå fel eller vilka
Exceptions som kastas. Men i detta exemplet så retunerar varje metod
ett custom exception baserat på bas Exception. På det sättet så är det
möjligt att ta hand om felen centralt.

#+BEGIN_SRC csharp
User ValidateUser(string username)
#+END_SRC

* [[./ResultString.cs][ResultString.cs]]

Nu använder vi Result<T,E> från [[https://github.com/vkhorikov/CSharpFunctionalExtensions][CSharpFunctionalExtensions]]. Detta ger
oss möjligheten att säga att metoden =ValidateUser= retunerar =User=
*ELLER* =string=. =string= i detta fallet är ett felmedelande som
retunerars från metoden.

Det viktiga här är att vi nu kan beskriva att metoden retunerar =User=
*ELLER* =string=!!!

#+BEGIN_SRC csharp
Result<User, string> ValidateUser(string username)
#+END_SRC

När vi nu har möjligheten att resonera om att något kan vara det ena
eller det andra så får vi tillgång till ett användbart mönster. Det
som kallas för =Bind=.

Bind används för att kedja ihop operationer som returnerar =Result<T,
E>=, på ett säkert sätt. Returnera tidigt vid fel — utan extra logik.
Kodflödet blir rent och tydligt. Du slipper if-satser och try/catch i
varje steg. Felhantering är tydligt, automatisk och konsekvent.

Om någon av operationerna skulle retunera =Result.Failure= kommer
kedjan att kortsluta och inga nästkommande operationer kommer köras.

#+BEGIN_SRC csharp
//     TSuccess, TError 
Result<int     ,string> a = ValidateUser("A")
                               .Bind(SaveUser)
                               .Bind(SendEmail);
#+END_SRC

I just denna koden är vi begränsade till att fel retuneras som en
sträng. Det är kanske inte helt optimalt och i senare steg visas hur
vi kan retunera mer data.

* [[./ResultStringLinq.cs][ResultStringLinq.cs]]

I detta exemplet så använder vi exakt samma tankar som ovan, varje
metod retunerar =Result<T, E>=. Men här tar vi hjälp av LINQ syntaxten
för att göra koden ännu mer lättläst, och vi får tillgång till
variable från metoder tidigare i kedjan.

#+BEGIN_SRC csharp
Result<int, string> a = from validaUser in ValidateUser("A") 
                        from savedUser in SaveUser(validaUser)
                        from emailReturnCode in SendEmail(savedUser)
                        select emailReturnCode;
#+END_SRC

* [[./ResultLinqAsync.cs][ResultLinqAsync.cs]]

Nu har vi kommit till sista delan.

#+BEGIN_SRC csharp
Result<User, Error> ValidateUser(string username)
#+END_SRC

Här har vi en metodsignatur som retunerar =User= eller =Error= där
=Error= är en hierarki av records.

#+BEGIN_SRC csharp
record Error(string msg);
record ValidationError(string msg) : Error(msg);
record SavedUserError(string msg) : Error(msg);
record SendEmailError(string msg) : Error(msg);
#+END_SRC

Genom att retunera ett =Error= så kan vi på ett central och tydligt
sätt hantera all fel.

#+BEGIN_SRC csharp
public static string HandleError(Error error) => error switch
{
    ValidationError ve => $"Validation error: {ve.msg}",
    SavedUserError sue => $"Saved user error: {sue.msg}",
    SendEmailError see => $"Send email error: {see.msg}",
    _ => "An unknown error occurred."
};
#+END_SRC

